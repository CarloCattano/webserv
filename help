// in Cgi.cpp

std::string runCommand(const std::string &scriptPath)
{
	const int TIMEOUT_SECONDS = 20;

	if (scriptPath.empty()) {
		throw std::invalid_argument("Empty script path");
	}

	int pipe_fd[2];
	if (pipe(pipe_fd) == -1) {
		std::cerr << "Failed to create pipe" << std::endl;
		exit(EXIT_FAILURE);
	}

	pid_t pid = fork();
	if (pid == -1) {
		std::cerr << "Failed to fork process" << std::endl;
		exit(EXIT_FAILURE);
	}

	if (pid == 0) {		   // Child process
		close(pipe_fd[0]); // Close the read end of the pipe

		// Redirect stdout to the write end of the pipe
		if (dup2(pipe_fd[1], STDOUT_FILENO) == -1) {
			std::cerr << "Failed to redirect stdout" << std::endl;
			exit(EXIT_FAILURE);
		}

		alarm(TIMEOUT_SECONDS);

		if (execl("/usr/bin/python3", "python3", relativePath(scriptPath).c_str(), NULL) == -1) {
			std::cerr << "Failed to execute Python script" << std::endl;
			exit(EXIT_FAILURE);
		}
		exit(EXIT_SUCCESS);
	}
	else {
		close(pipe_fd[1]);

		char buffer[128]; // output from the child process
		std::string result;
		ssize_t bytes_read;

		while ((bytes_read = read(pipe_fd[0], buffer, sizeof(buffer))) > 0) {
			result.append(buffer, bytes_read);
		}

		close(pipe_fd[0]);

		int status;
		waitpid(pid, &status, 0); // blocks until the child process exits

		if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
			std::cerr << "Child process failed" << std::endl;
			exit(EXIT_FAILURE);
		}

		return result;
	}
	return "";
}

// in Server.cpp

void Server::start_listen()
{
	_socket_fd = socket(AF_INET, SOCK_STREAM, 0);
	if (_socket_fd == -1)
		throw SocketErrorException();

	int opt = 1;
	setsockopt(_socket_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));

	if (bind(_socket_fd, (struct sockaddr *)&_server_address, sizeof(_server_address)) == -1)
		throw BindErrorException();

	if (listen(_socket_fd, BACKLOG) == -1)
		throw ListenErrorException();
}

void Server::await_connections()
{
	struct pollfd fds[MAX_EVENTS];
	fds[0].fd = _socket_fd;
	fds[0].events = POLLIN;
	std::cout << "Server started on http://localhost:" << _port << std::endl;

	// handle ctrl+c

	signal(SIGINT, stop);

	while (true) {
		int activity = poll(fds, MAX_EVENTS, -1);
		if (activity == -1) {
			perror("poll");
			continue;
		}

		if (fds[0].revents & POLLIN) {
			int client_fd = accept(_socket_fd, NULL, NULL);
			if (client_fd == -1) {
				perror("accept");
				continue;
			}

			handle_request(client_fd);
			fcntl(client_fd, F_SETFL, O_NONBLOCK);
			close(client_fd);
		}
	}
	close(_socket_fd);
}

void Server::start()
{
	start_listen();
	await_connections();
}

void Server::handle_request(int client_fd)
{
	char buffer[BUFFER_SIZE];
	int size = recv(client_fd, buffer, BUFFER_SIZE, 0);

	if (size == -1) {
		perror("recv");
		return;
	}

	std::string requested_file_path = extract_requested_file_path(buffer);
	std::string file_content = readFileToString("website" + requested_file_path);
	std::string content_type = getContentType(requested_file_path);

	if (requested_file_path.find(".py") != std::string::npos) {
		pid_t pid = fork();

		if (pid == -1) {
			perror("fork");
			return;
		}

		if (pid == 0) {
			// Child process - for every request
			try {
				close(_socket_fd); // Close the listening socket in the child process
				Cgi cgi;
				std::string cgi_response = cgi.run(CGI_BIN);

				std::string response = "HTTP/1.1 200 OK\r\nContent-Type: " + content_type +
					"\r\nContent-Length: " + intToString(cgi_response.length()) + "\r\n\r\n" +
					cgi_response.c_str();
				send(client_fd, response.c_str(), response.size(), 0);
				close(client_fd);
				exit(0);
			}
			catch (std::exception &e) {
				std::cerr << "Error: " << e.what() << std::endl;
				exit(1);
			}
		}
		else {
			// Parent process
			// Close the client socket in the parent process and continue accepting connections
			close(client_fd);
		}
	}
	else if (file_content.empty()) {
		std::string errResponse = "HTTP/1.1 404 Not Found\r\n\r\n";
		send(client_fd, errResponse.c_str(), errResponse.size(), 0);
		close(client_fd);
	}
	else {
		std::string response = "HTTP/1.1 200 OK\r\nContent-Type: " + content_type +
			"\r\nContent-Length: " + intToString(file_content.length()) + "\r\n\r\n" + file_content;

		send(client_fd, response.c_str(), response.size(), 0);
		close(client_fd);
	}
}
